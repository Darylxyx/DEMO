{"version":3,"sources":["webpack:///./src/views/Map3d.vue?20f3","webpack:///./node_modules/core-js/library/fn/get-iterator.js","webpack:///./src/views/Map3d.vue?15dc","webpack:///src/views/Map3d.vue","webpack:///./src/views/Map3d.vue?4e7d","webpack:///./src/views/Map3d.vue","webpack:///./node_modules/@babel/runtime-corejs2/core-js/get-iterator.js","webpack:///./node_modules/core-js/library/modules/core.get-iterator.js","webpack:///./node_modules/latlon-geohash/latlon-geohash.js"],"names":["_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_index_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Map3d_vue_vue_type_style_index_0_id_d98330d4_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0__","__webpack_require__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_10_oneOf_1_0_node_modules_css_loader_index_js_ref_10_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_10_oneOf_1_2_node_modules_less_loader_dist_cjs_js_ref_10_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Map3d_vue_vue_type_style_index_0_id_d98330d4_lang_less_scoped_true___WEBPACK_IMPORTED_MODULE_0___default","n","module","exports","render","_vm","this","_h","$createElement","_c","_self","staticClass","ref","attrs","id","staticRenderFns","THREE","window","TWEEN","PI","Math","radius","mainGroup","Clock","Group","lineGroup","sphereGroup","globalGroup","pointsGroup","scanGroup","pathGroup","Map3dvue_type_script_lang_js_","mixins","threeMixin","math","data","runCount","stopCount","offlineCount","isLoading","methods","queryData","_queryData","Object","asyncToGenerator","regeneratorRuntime","mark","_callee","run","silence","offline","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","_step","obj","coord","lglt","randomSort","dataSlice","dataMap","pointsAnimateStart","pathData","wrap","_context","prev","next","children","forEach","cloudGroup","cloud","tween","start","target","slice","floor","length","diff","random","undefined","get_iterator_default","car","done","value","geoHashKey","latlon_geohash_default","a","decode","lon","lat","t0","push","abrupt","t1","return","finish","sort","type","color","rgbcolor","twinkle","drawTruck","path","topLine100","addPath","stop","apply","arguments","_this2","promise_default","resolve","promises","map","item","pro","solve","add","drawPoints","all","then","initWebGL","_this$initBasics","initBasics","$refs","canvas","position","x","y","z","antialias","clearColor","scene","camera","renderer","lookAt","v3","addLight","addSphere","addBackground","initMap","renderScene","update","requestAnimationFrame","_this3","boundary","province","drawMap","name","addAxes","axes","initAxes","lightGroup","ambientLight","initLight","directionalLight","shadow","near","far","left","right","top","bottom","addControl","control","initControls","rotateSpeed","zoomSpeed","panSpeed","_addSphere","_callee2","geom","_ref4","url","mat","sphere","_context2","initGeometry","e","t","bind","sent","default","loadTexture","initMaterial","Mesh","scale","set","rotation","globalAnimate","onUpdate","tween1","Tween","to","tween2","chain","addScanLine","i","LineBasicMaterial","opacity","transparent","scanLine","Line","scanAnimate","backGroup","geo","Geometry","j","particle","vertices","stars","createPoints","bindTwinkle","inTime","outTime","duration","delay","pointsArr","_this4","pList","point","indexOf","split","lng","Number","_this4$lglt2xyx","lglt2xyx","lineColor","linewidth","line","initLine","pData","_this5","pointSize","mapParam","splice","params","size","depthTest","splitCount","splitArr","splitArray","arr","points","p","_this5$lglt2xyx","_this5$lglt2xyx2","_this6","rank","list","result","drawPath","lineGeom","lineMat","drawPathFlow","frag","round","pointsGeom","_this","initData","index","I","_i","geometry","verticesNeedUpdate","onComplete","repeat","Infinity","initGUI","_this7","gui","dat_gui_module","controls","cameraX","cameraY","cameraZ","lookX","lookY","lookZ","fogFar","onChange","fog","Fog","mounted","views_Map3dvue_type_script_lang_js_","component","componentNormalizer","__webpack_exports__","anObject","get","getIterator","it","iterFn","TypeError","call","Geohash","base32","encode","precision","hash","posn","isNaN","Error","idx","bit","evenBit","geohash","latMin","latMax","lonMin","lonMax","lonMid","latMid","charAt","bounds","sw","ne","toFixed","log","LN10","toLowerCase","chr","bitN","adjacent","direction","neighbour","s","w","border","lastCh","parent","neighbours","se","nw"],"mappings":"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","file":"js/chunk-564c9cf1.1d4547ea.js","sourcesContent":["import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../node_modules/css-loader/index.js??ref--10-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Map3d.vue?vue&type=style&index=0&id=d98330d4&lang=less&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-oneOf-1-0!../../node_modules/css-loader/index.js??ref--10-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--10-oneOf-1-2!../../node_modules/less-loader/dist/cjs.js??ref--10-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Map3d.vue?vue&type=style&index=0&id=d98330d4&lang=less&scoped=true&\"","require('../modules/web.dom.iterable');\nrequire('../modules/es6.string.iterator');\nmodule.exports = require('../modules/core.get-iterator');\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"container\"},[_c('div',{ref:\"stats\"}),_c('div',{ref:\"canvas\",attrs:{\"id\":\"WebGL-output\"}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div class=\"container\">\n        <div ref='stats'></div>\n        <div ref='canvas' id='WebGL-output'></div>\n    </div>\n</template>\n<script>\nimport Geohash from 'latlon-geohash';\nimport { GUI } from 'dat.gui';\nimport mixin from '@/mixins/threeMixin';\nimport math from '@/mixins/math';\nimport boundaryJSON from '@/assets/js/boundary';\nimport carJSON from '@/assets/js/car.json';\nimport pathJSON from '@/assets/js/path.json';\n\nconst THREE = window.THREE;\nconst TWEEN = window.TWEEN;\nconst PI = Math.PI;\nconst radius = 100;\nlet globalDirec = true;\nconst clock = new THREE.Clock();\n\nconst mainGroup = new THREE.Group(); // 顶级组\nconst lineGroup = new THREE.Group(); // 地图边界线组\nconst sphereGroup = new THREE.Group(); // 地球组\nconst globalGroup = new THREE.Group();\nconst pointsGroup = new THREE.Group(); // 车辆坐标点组\nconst scanGroup = new THREE.Group(); // 扫描线组\nconst pathGroup = new THREE.Group(); // 路径组\nexport default {\n    mixins: [mixin, math],\n    data() {\n        return {\n            runCount: 0,\n            stopCount: 0,\n            offlineCount: 0,\n            isLoading: false,\n        };\n    },\n    methods: {\n        async queryData() {\n            this.isLoading = true;\n            // 查询车辆信息\n            let run = [];\n            let silence = [];\n            let offline = [];\n            for (const obj of carJSON) {\n                if (obj.geoHashKey) {\n                    const coord = Geohash.decode(obj.geoHashKey);\n                    const lglt = [coord.lon, coord.lat];\n                    switch (obj.value) {\n                        case 2:\n                            run.push(lglt);\n                            break;\n                        case 1:\n                            silence.push(lglt);\n                            break;\n                        // case 0:\n                        //     offline.push(lglt);\n                        //     break;\n                        default:\n                            offline.push(lglt);\n                            break;\n                    }\n                }\n            }\n            this.runCount = run.length;\n            this.stopCount = silence.length;\n            function randomSort() {\n                const diff = Math.random() - Math.random();\n                return diff;\n            }\n            function dataSlice(target) {\n                return target.slice(0, Math.floor(target.length / 7));\n            }\n            run.sort(randomSort);\n            silence.sort(randomSort);\n            offline.sort(randomSort);\n            run = dataSlice(run);\n            silence = dataSlice(silence);\n            offline = dataSlice(offline);\n            const dataMap = [{\n                type: 'run',\n                data: run,\n                color: 0x19D190,\n                rgbcolor: 'rgba(25,209,144,1)',\n                twinkle: true,\n            }, {\n                type: 'silence',\n                data: silence,\n                color: 0x2934CE,\n                rgbcolor: 'rgba(41,52,206,1)',\n            }, {\n                type: 'offline',\n                data: offline,\n                color: 0x303A61,\n                rgbcolor: 'rgba(48,58,97,1)',\n            }];\n\n            await this.drawTruck(dataMap);\n            function pointsAnimateStart() {\n                pointsGroup.children.forEach((cloudGroup) => {\n                    cloudGroup.children.forEach((cloud) => {\n                        if (cloud.tween) cloud.tween.start();\n                    });\n                });\n            }\n            pointsAnimateStart();\n\n            // 查询线路信息\n            const pathData = pathJSON.data.topLine100.slice(0, 300);\n            this.addPath(pathData);\n        },\n        drawTruck(dataMap) {\n            return new Promise((resolve) => {\n                const promises = dataMap.map((item) => {\n                    const pro = new Promise((solve) => {\n                        pointsGroup.add(this.drawPoints(item));\n                        solve();\n                    });\n                    return pro;\n                });\n                Promise.all(promises).then(() => {\n                    resolve();\n                });\n            });\n        },\n        initWebGL() {\n            const {\n                scene,\n                camera,\n                renderer,\n            } = this.initBasics(this.$refs.canvas, { position: { x: -45, y: 62, z: -140 }, antialias: true }, { clearColor: 0x000000 });\n            this.scene = scene;\n            this.camera = camera;\n            this.renderer = renderer;\n            this.scene.add(mainGroup);\n            camera.lookAt(this.v3(64, 20, 150));\n\n            // scene.fog = new THREE.Fog(0x000000, 0.015, 1000);\n\n            // const stats = this.initStats(this.$refs.stats);\n            // const control = this.addControl();\n            // console.log(clock);\n\n            // this.addAxes();\n\n            this.addLight(); // 光源\n\n            this.addSphere(); // 地球\n\n            // this.addScanLine(); // 扫描线\n            this.addBackground(); // 星空背景\n\n            this.initMap(); // 绘制地图\n\n            // this.initGUI();\n            const renderScene = () => {\n                // stats.update();\n                // const delta = clock.getDelta();\n                // control.update(delta);\n                // this.scanAnimate();\n                TWEEN.update();\n                requestAnimationFrame(renderScene);\n                renderer.render(scene, camera);\n            };\n            renderScene();\n        },\n        initMap() {\n            globalGroup.add(lineGroup);\n            globalGroup.add(pointsGroup);\n            mainGroup.add(globalGroup);\n            boundaryJSON.forEach((province) => {\n                lineGroup.add(this.drawMap(province.name, province.data));\n            });\n        },\n        addAxes() {\n            const axes = this.initAxes(150);\n            mainGroup.add(axes);\n        },\n        addLight() { // 光源\n            const lightGroup = new THREE.Group();\n            const ambientLight = this.initLight('Ambient', {\n                color: 0x696969,\n            });\n            const directionalLight = this.initLight('Directional', {\n                color: 0xffffff,\n                position: { x: -500, y: 250, z: -100 },\n                shadow: {\n                    camera: {\n                        near: 2,\n                        far: radius * 2.5,\n                        left: -radius * 2,\n                        right: radius * 2,\n                        top: radius * 2,\n                        bottom: -radius * 2,\n                    },\n                },\n            });\n            // const helper = new THREE.CameraHelper(directionalLight.shadow.camera);\n            // lightGroup.add(helper);\n            lightGroup.add(ambientLight);\n            lightGroup.add(directionalLight);\n            mainGroup.add(lightGroup);\n        },\n        addControl() {\n            const control = this.initControls('Trackball', this.camera, {\n                rotateSpeed: 1.0,\n                zoomSpeed: 1.0,\n                panSpeed: 1.0,\n            });\n            return control;\n        },\n        async addSphere() { // 球\n            const geom = this.initGeometry('Sphere', radius, 40, 40);\n            const { default: url } = await import('@/assets/imgs/world.png');\n            const map = this.loadTexture(url);\n            const mat = this.initMaterial('MeshPhong', { color: 0x192452 }); //0x192452\n            mat.map = map;\n            const sphere = new THREE.Mesh(geom, mat);\n            sphere.scale.set(-1, -1, -1);\n            sphere.rotation.y = PI;\n            sphereGroup.add(sphere);\n            globalGroup.add(sphereGroup);\n        },\n        globalAnimate() {\n            const obj = { y: 0 };\n            function onUpdate(obj) {\n                globalGroup.rotation.y = obj.y;\n            }\n            const tween1 = new TWEEN.Tween(obj)\n                .to({ y: 0.1 }, 20000)\n                .onUpdate(onUpdate);\n            const tween2 = new TWEEN.Tween(obj)\n                .to({ y: -0.1 }, 20000)\n                .onUpdate(onUpdate);\n            tween1.chain(tween2);\n            tween2.chain(tween1);\n            tween1.start();\n        },\n        addScanLine() {\n            for (let i = 0; i < 8; i++) {\n                const geom = this.initGeometry('Circle', radius + 0.2, 40, 0, PI);\n                const mat = new THREE.LineBasicMaterial({\n                    color: 0xF5F5F5,\n                    opacity: i / 14,\n                    transparent: true,\n                });\n                const scanLine = new THREE.Line(geom, mat);\n                scanLine.rotation.x += i * 0.02;\n                scanGroup.add(scanLine);\n            }\n            mainGroup.add(scanGroup);\n        },\n        scanAnimate() {\n            scanGroup.rotation.x += 0.02;\n            if (scanGroup.rotation.x >= PI * 2) scanGroup.rotation.x = 0;\n        },\n        addBackground() {\n            const backGroup = new THREE.Group();\n            for (let i = 0; i < 10; i++) {\n                const geo = new THREE.Geometry();\n                for (let j = 0; j < 100; j++) {\n                    const x = Math.random() * 600 - 300;\n                    const y = Math.random() * 400 - 200;\n                    const z = 100;\n                    const particle = this.v3(x, y, z);\n                    geo.vertices.push(particle);\n                }\n                const stars = this.createPoints(geo, { map: null, color: 0xffffff });\n                this.bindTwinkle(stars, {\n                    inTime: 1000,\n                    outTime: 1000,\n                    duration: 3000,\n                    delay: Math.floor(Math.random() * 1000),\n                });\n                stars.tween.start();\n                backGroup.add(stars);\n            }\n            backGroup.rotation.y = PI / 9;\n            mainGroup.add(backGroup);\n        },\n        drawMap(name, pointsArr) {\n            const pList = [];\n            pointsArr.forEach((point) => {\n                if (point.indexOf(', ') > -1) {\n                    point = point.split(', ');\n                } else {\n                    point = point.split(',');\n                }\n                const lng = Number(point[0]);\n                const lat = point[1];\n                const { x, y, z } = this.lglt2xyx(lng + 90, lat, radius);\n                const particle = this.v3(x, y, z);\n                pList.push(particle);\n            });\n            let lineColor = 0x145385;\n            let linewidth = 1;\n            // if (name === '中国' || name === '台湾省') { // 轮廓加粗\n            //     lineColor = 0x6EFFFF;\n            //     linewidth = 1;\n            // }\n            const line = this.initLine(pList, {\n                color: lineColor,\n                linewidth,\n                transparent: true,\n                opacity: 0.6,\n            });\n            return line;\n        },\n        drawPoints(pData) { // 绘制车辆点\n            const cloudGroup = new THREE.Group();\n            let pointSize = 0.15;\n            const mapParam = [{\n                pro: 0,\n                color: pData.rgbcolor,\n            }, {\n                pro: 0.8,\n                color: pData.rgbcolor,\n            }, {\n                pro: 1,\n                color: 'rgba(0, 0, 0, 1)',\n            }];\n            if (pData.type === 'run') { // 运行的车辆增加光晕效果\n                pointSize = 0.3;\n                mapParam.splice(2, 0, { pro: 0.81, color: 'rgba(255,255,224, 1)' });\n            }\n            // console.log(mapParam);\n            const params = {\n                size: pointSize,\n                depthTest: false,\n            };\n            if (pData.twinkle) { // 车辆是否需要闪烁\n                const splitCount = 100; // 用于分组，实现闪烁效果\n                const splitArr = this.splitArray(pData.data, splitCount);\n                splitArr.forEach((arr) => {\n                    const points = new THREE.Geometry();\n                    arr.forEach((p) => {\n                        const { x, y, z } = this.lglt2xyx(p[0] + 90, p[1], radius);\n                        const particle = this.v3(x, y, z);\n                        points.vertices.push(particle);\n                    });\n                    const cloud = this.createPoints(points, params, mapParam);\n                    this.bindTwinkle(cloud);\n                    cloudGroup.add(cloud);\n                });\n            } else {\n                const points = new THREE.Geometry();\n                pData.data.forEach((p) => {\n                    const { x, y, z } = this.lglt2xyx(p[0] + 90, p[1], radius);\n                    const particle = this.v3(x, y, z);\n                    points.vertices.push(particle);\n                });\n                const cloud = this.createPoints(points, params, mapParam);\n                cloudGroup.add(cloud);\n            }\n            return cloudGroup;\n        },\n        addPath(data) {\n            data.forEach((path, rank) => {\n                const points = path.points.split(';');\n                const list = points.map((p) => {\n                    p = p.split(',');\n                    const lng = Number(p[0]);\n                    const lat = p[1];\n                    const result = this.lglt2xyx(lng + 90, lat, radius + 0.1);\n                    return result;\n                });\n                this.drawPath(list, rank);\n            });\n        },\n        drawPath(list, rank) { // 绘制线路\n            const lineGeom = new THREE.Geometry();\n            list.forEach((p) => {\n                lineGeom.vertices.push(p);\n            });\n            const lineMat = new THREE.LineBasicMaterial({\n                color: 0xFFD700,\n                opacity: 0.2,\n                transparent: true,\n            });\n            const line = new THREE.Line(lineGeom, lineMat);\n            pathGroup.add(line);\n            this.drawPathFlow(list, rank);\n            globalGroup.add(pathGroup);\n        },\n        drawPathFlow(list, rank) { // 线路流动效果\n            const length = list.length;\n            const frag = Math.round(list.length / 5);\n            const pointsGeom = new THREE.Geometry(); // 线路轨迹动画点\n            for (let i = 0; i < frag; i++) {\n                pointsGeom.vertices.push(this.v3(0, 0, 0));\n            }\n            const mapParam = [{\n                pro: 0,\n                color: 'rgba(255,215,0,1)',\n            }, {\n                pro: 0.9,\n                color: 'rgba(255,255,255,0.5)',\n            }, {\n                pro: 1,\n                color: 'rgba(0,0,0,1)',\n            }];\n            let pointSize = 0.2;\n            if (rank < 50) {\n                pointSize = 0.3;\n            } else if (rank >= 50 && rank < 200) {\n                pointSize = 0.25;\n            }\n            const points = this.createPoints(pointsGeom, {\n                color: 0xffffff,\n                size: pointSize,\n                depthTest: false,\n            }, mapParam);\n\n            const _this = this;\n            const initData = { index: 0 };\n            function onUpdate(obj) {\n                const I = Math.floor(obj.index);\n                const vertices = [];\n                for (let i = I; i > I - frag; i--) {\n                    if (list[i]) {\n                        vertices.push(list[i]);\n                    } else {\n                        vertices.push(_this.v3(500, 500, 500));\n                    }\n                }\n                points.geometry.vertices = vertices;\n                points.geometry.verticesNeedUpdate = true;\n            }\n            function onComplete() {\n                initData.index = 0;\n            }\n            const duration = 2000;\n            const delay = Math.floor(Math.random() * duration * 2);\n            // const delay = duration / 2;\n            const tween = new TWEEN.Tween(initData)\n                .to({ index: length + frag }, duration)\n                .delay(delay)\n                .onUpdate(onUpdate)\n                .onComplete(onComplete)\n                .repeat(Infinity);\n            pathGroup.add(points);\n            tween.start();\n\n            this.globalAnimate();\n        },\n        initGUI() {\n            const gui = new GUI();\n            const controls = {\n                cameraX: this.camera.position.x,\n                cameraY: this.camera.position.y,\n                cameraZ: this.camera.position.z,\n                lookX: 64,\n                lookY: 20,\n                lookZ: 150,\n                fogFar: 300,\n            };\n            let x = controls.lookX;\n            let y = controls.lookY;\n            let z = controls.lookZ;\n            const lookAt = () => {\n                this.camera.lookAt(this.v3(x, y, z));\n            };\n            gui.add(controls, 'cameraX', -200, 200).onChange((e) => {\n                this.camera.position.x = e;\n            });\n            gui.add(controls, 'cameraY', -200, 200).onChange((e) => {\n                this.camera.position.y = e;\n            });\n            gui.add(controls, 'cameraZ', -200, 200).onChange((e) => {\n                this.camera.position.z = e;\n            });\n            gui.add(controls, 'lookX', -200, 200).onChange((e) => {\n                x = e;\n                lookAt();\n            });\n            gui.add(controls, 'lookY', -200, 200).onChange((e) => {\n                y = e;\n                lookAt();\n            });\n            gui.add(controls, 'lookZ', -200, 200).onChange((e) => {\n                z = e;\n                lookAt();\n            });\n            gui.add(controls, 'fogFar', 0, 2000).onChange((e) => {\n                this.scene.fog = new THREE.Fog(0xffffff, 0.015, e);\n            });\n        },\n    },\n    mounted() {\n        this.initWebGL();\n        this.queryData();\n    },\n};\n</script>\n<style lang='less' scoped>\n.container {\n    position: relative;\n    width: 100%;\n    height: 100%;\n\n    #WebGL-output {\n        overflow: hidden;\n        width: 100%;\n        height: 100%;\n    }\n\n    .map-bar{\n        position: absolute;\n        width: 100%;\n        height: .86rem;\n        display:flex;\n        justify-content: center;\n        align-items: center;\n        top:0;\n        .truck-status{\n            font-size: .18rem;\n            color: #7782AC;\n            margin-right: .7rem;\n            .icon{\n                margin-top: .19rem;\n                width: .18rem;\n                height: .18rem;\n                float: left;\n                margin-right: .1rem;\n                border-radius: 50%;\n                &.moving{\n                    background-image: linear-gradient(-180deg, #19D190 0%, #0D8477 100%);\n                }\n                &.stop{\n                    background-image: linear-gradient(45deg, #2934CE 0%, #86B0FF 100%);\n                }\n                &.offline{\n                    background-image: linear-gradient(45deg, #303A61 0%, #64709F 100%);\n                }\n            }\n            .num{\n                font-size: .32rem;\n                margin-left: .1rem;\n                color: #C7CFEE;\n            }\n        }\n    }\n}\n</style>","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Map3d.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Map3d.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./Map3d.vue?vue&type=template&id=d98330d4&scoped=true&\"\nimport script from \"./Map3d.vue?vue&type=script&lang=js&\"\nexport * from \"./Map3d.vue?vue&type=script&lang=js&\"\nimport style0 from \"./Map3d.vue?vue&type=style&index=0&id=d98330d4&lang=less&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"d98330d4\",\n  null\n  \n)\n\nexport default component.exports","module.exports = require(\"core-js/library/fn/get-iterator\");","var anObject = require('./_an-object');\nvar get = require('./core.get-iterator-method');\nmodule.exports = require('./_core').getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n","/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2016 / MIT Licence  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n'use strict';\n\n\n/**\n * Geohash encode, decode, bounds, neighbours.\n *\n * @namespace\n */\nvar Geohash = {};\n\n/* (Geohash-specific) Base32 map */\nGeohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n\n/**\n * Encodes latitude/longitude to geohash, either to specified precision or to automatically\n * evaluated precision.\n *\n * @param   {number} lat - Latitude in degrees.\n * @param   {number} lon - Longitude in degrees.\n * @param   {number} [precision] - Number of characters in resulting geohash.\n * @returns {string} Geohash of supplied latitude/longitude.\n * @throws  Invalid geohash.\n *\n * @example\n *     var geohash = Geohash.encode(52.205, 0.119, 7); // geohash: 'u120fxw'\n */\nGeohash.encode = function(lat, lon, precision) {\n    // infer precision?\n    if (typeof precision == 'undefined') {\n        // refine geohash until it matches precision of supplied lat/lon\n        for (var p=1; p<=12; p++) {\n            var hash = Geohash.encode(lat, lon, p);\n            var posn = Geohash.decode(hash);\n            if (posn.lat==lat && posn.lon==lon) return hash;\n        }\n        precision = 12; // set to maximum\n    }\n\n    lat = Number(lat);\n    lon = Number(lon);\n    precision = Number(precision);\n\n    if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');\n\n    var idx = 0; // index into base32 map\n    var bit = 0; // each char holds 5 bits\n    var evenBit = true;\n    var geohash = '';\n\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    while (geohash.length < precision) {\n        if (evenBit) {\n            // bisect E-W longitude\n            var lonMid = (lonMin + lonMax) / 2;\n            if (lon >= lonMid) {\n                idx = idx*2 + 1;\n                lonMin = lonMid;\n            } else {\n                idx = idx*2;\n                lonMax = lonMid;\n            }\n        } else {\n            // bisect N-S latitude\n            var latMid = (latMin + latMax) / 2;\n            if (lat >= latMid) {\n                idx = idx*2 + 1;\n                latMin = latMid;\n            } else {\n                idx = idx*2;\n                latMax = latMid;\n            }\n        }\n        evenBit = !evenBit;\n\n        if (++bit == 5) {\n            // 5 bits gives us a character: append it and start over\n            geohash += Geohash.base32.charAt(idx);\n            bit = 0;\n            idx = 0;\n        }\n    }\n\n    return geohash;\n};\n\n\n/**\n * Decode geohash to latitude/longitude (location is approximate centre of geohash cell,\n *     to reasonable precision).\n *\n * @param   {string} geohash - Geohash string to be converted to latitude/longitude.\n * @returns {{lat:number, lon:number}} (Center of) geohashed location.\n * @throws  Invalid geohash.\n *\n * @example\n *     var latlon = Geohash.decode('u120fxw'); // latlon: { lat: 52.205, lon: 0.1188 }\n */\nGeohash.decode = function(geohash) {\n\n    var bounds = Geohash.bounds(geohash); // <-- the hard work\n    // now just determine the centre of the cell...\n\n    var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;\n    var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;\n\n    // cell centre\n    var lat = (latMin + latMax)/2;\n    var lon = (lonMin + lonMax)/2;\n\n    // round to close to centre without excessive precision: ⌊2-log10(Δ°)⌋ decimal places\n    lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));\n    lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));\n\n    return { lat: Number(lat), lon: Number(lon) };\n};\n\n\n/**\n * Returns SW/NE latitude/longitude bounds of specified geohash.\n *\n * @param   {string} geohash - Cell that bounds are required of.\n * @returns {{sw: {lat: number, lon: number}, ne: {lat: number, lon: number}}}\n * @throws  Invalid geohash.\n */\nGeohash.bounds = function(geohash) {\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n\n    geohash = geohash.toLowerCase();\n\n    var evenBit = true;\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    for (var i=0; i<geohash.length; i++) {\n        var chr = geohash.charAt(i);\n        var idx = Geohash.base32.indexOf(chr);\n        if (idx == -1) throw new Error('Invalid geohash');\n\n        for (var n=4; n>=0; n--) {\n            var bitN = idx >> n & 1;\n            if (evenBit) {\n                // longitude\n                var lonMid = (lonMin+lonMax) / 2;\n                if (bitN == 1) {\n                    lonMin = lonMid;\n                } else {\n                    lonMax = lonMid;\n                }\n            } else {\n                // latitude\n                var latMid = (latMin+latMax) / 2;\n                if (bitN == 1) {\n                    latMin = latMid;\n                } else {\n                    latMax = latMid;\n                }\n            }\n            evenBit = !evenBit;\n        }\n    }\n\n    var bounds = {\n        sw: { lat: latMin, lon: lonMin },\n        ne: { lat: latMax, lon: lonMax },\n    };\n\n    return bounds;\n};\n\n\n/**\n * Determines adjacent cell in given direction.\n *\n * @param   geohash - Cell to which adjacent cell is required.\n * @param   direction - Direction from geohash (N/S/E/W).\n * @returns {string} Geocode of adjacent cell.\n * @throws  Invalid geohash.\n */\nGeohash.adjacent = function(geohash, direction) {\n    // based on github.com/davetroy/geohash-js\n\n    geohash = geohash.toLowerCase();\n    direction = direction.toLowerCase();\n\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n    if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');\n\n    var neighbour = {\n        n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],\n        s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],\n        e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],\n        w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],\n    };\n    var border = {\n        n: [ 'prxz',     'bcfguvyz' ],\n        s: [ '028b',     '0145hjnp' ],\n        e: [ 'bcfguvyz', 'prxz'     ],\n        w: [ '0145hjnp', '028b'     ],\n    };\n\n    var lastCh = geohash.slice(-1);    // last character of hash\n    var parent = geohash.slice(0, -1); // hash without last character\n\n    var type = geohash.length % 2;\n\n    // check for edge-cases which don't share common prefix\n    if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {\n        parent = Geohash.adjacent(parent, direction);\n    }\n\n    // append letter for direction to parent\n    return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));\n};\n\n\n/**\n * Returns all 8 adjacent cells to specified geohash.\n *\n * @param   {string} geohash - Geohash neighbours are required of.\n * @returns {{n,ne,e,se,s,sw,w,nw: string}}\n * @throws  Invalid geohash.\n */\nGeohash.neighbours = function(geohash) {\n    return {\n        'n':  Geohash.adjacent(geohash, 'n'),\n        'ne': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'e'),\n        'e':  Geohash.adjacent(geohash, 'e'),\n        'se': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'e'),\n        's':  Geohash.adjacent(geohash, 's'),\n        'sw': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'w'),\n        'w':  Geohash.adjacent(geohash, 'w'),\n        'nw': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'w'),\n    };\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nif (typeof module != 'undefined' && module.exports) module.exports = Geohash; // CommonJS, node.js\n"],"sourceRoot":""}